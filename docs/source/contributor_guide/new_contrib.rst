================
New contribution
================

üëã Everyone is welcomed to contribute with their own forward code. We aim to reduce the
barrier of contributing so don't worry if you are not familiar with some technical
stuff - we are here to help.


Add your own Espresso problem
-----------------------------

#. A new contribution to Espresso has to conform to a consistent
   file structure. The simplest way to ensure that a new contribution includes
   all files is to start the creation of a new problem from the template:

   .. code-block:: bash

        python <path-to-espresso>/espresso_machine/new_contribution/create_new_contrib.py <problem-name>

   Replacing :code:`path-to-espresso` with your path to the espresso folder you've just cloned,
   and :code:`problem-name` with your Espresso problem name, with lower case words connected
   by underscores (e.g. :code:`gravity_density`, :code:`polynomial_regression`).

#. Navigate to folder :code:`<path-to-espresso>/contrib/<problem-name>`, and you'll see template 
   files needed for a new contribution. Each Espresso example is organised around a
   central class object that contains, at minimum, a set of functions with names
   that are shared by all examples.

   .. figure:: ../_static/contrib_edit1.png
    :align: center

#. Read instructions in the :code:`README.md` file, and you will know what to do next üßëüèΩ‚Äçüíªüë©üèª‚Äçüíªüë®‚Äçüíª

   #. You should already have all the "pre-requisites" installed if you've gone through 
      the steps above.

   #. See a list of "Checklists". These are pretty much all the things you've
      got to do to complete this contribution.

   #. When you'd like to perform a quick local test by running your own code, run
      :code:`python espresso_machine/build_package/validate.py -c <problem-name>`

   #. When you think you've finished the coding, run
      :code:`python espresso_machine/build_package/build.py --validate`

There are several things to keep in mind to make a contribution successful:

1. All files as generated by the template must be present in the contributed
   folder.

2. Choose a sensible, unique name for your contribution that makes it easy to
   understand what the new example is about. The name can contain more than
   one word, connected by ``_`` (i.e. NEW_PROBLEM). Spaces are not allowed.

3. The name of the new contribution (NEW_PROBLEM) must be used twice:

   - for the folder name: espresso/contrib/NEW_PROBLEM
   - for the central class object in NEW_PROBLEM/__init__.py, i.e.::

       ```
       class new_problem():
       ...
       ```

5. Some contributions might want to include measured values. To ensure that any
   included data can be accessed on any platform, the Python package ``pkgutil``
   has to be used. A contribution can include small datasets in plain textfiles
   (ASCII or similar). Data files are stored in ``/contrib/NEW_PROBLEM/data/``
   and can be loaded using the following code::

     tmp = pkgutil.get_data(__name__, "data/datafile.txt")
     tmp2=tmp.decode("utf-8")
     self.m=np.loadtxt(StringIO(tmp2))
     del  tmp, tmp2

   The decoder might have to be adjusted to load the data successfully. For a
   full list of encodings, see
   `here
   <https://docs.python.org/3/library/codecs.html#standard-encodings/>`_.


6. The contribution can include problem-specific functions, but should always
   include the following standard functions::

     - get_model: Returns the starting model as numpy array
     - get_data: Returns reasonable values that could be measured on the recording
        locations. This can be real measured values, or prepared synthetic
        data with reasonable noise added; numpy array.
     - forward: Contains the forward calculation. Returns synthetic data values
        based on the input model and specified recording locations; numpy array.
     - plot_model: Visualises the problem. This should include a sensible visualisation
        of the model and the synthetic data.

   There are many more functions and values that a new contribution can contain, for example::

     - inversion_suggestion: A string containing inversion suggestions..
     - gradient: Returns the Jacobian of the problem, given the model and recording locations.
     - reg_param: Contains a sensible value for regularisation parameter
     - dx: Spatial resolution in x-direction
     - dt: temporal resolution
     - nt: Number of time steps
     - The possibilities are endless! Whatever information you find helpful is
        probably also helpful for the user.

7. We aim to follow `Python PEP8 style conventions <https://peps.python.org/pep-0008/>`
   to make source code readable for any user. Once your forward code is converted
   into a contribution for Espresso, we recommend to use `PyLint
   <https://pypi.org/project/pylint/>`_  to enforce PEP8 coding standard in the
   new contribution.

Jupyter Notebook
----------------

Additionally, we encourage you to add a Jupyter Notebook with an identical name
into the folder Jupyter Notebooks that contains the following:

1. An extensive description of the new Espresso Problem, containing
   information about (but not limited to)...:

   - the forward calculation (ie. the underlying physics) and how it was implemented.
   - which inversion method is used (and regularisation) and how it was implemented.
   - the physical unit of relevant variables, but at least of ``model`` and ``data``.
   - all changeable parameters, possibly in a list.


2. An example of the new problem being used, with a reasonable output.


.. _appendix_build_steps:

Appendix I: installation steps
------------------------------

To install your development version locally, run the following in your terminal:

.. code-block:: console

   $ python espresso_machine/build_package/build.py


The following table describes what happens when we package Espresso:

.. list-table:: How Espresso is packaged
   :widths: 10 45 45
   :header-rows: 1

   * - Step
     - What's done
     - How it's done
   * - 1
     - Clean ``_esp_build/``
     - ``shutil.rmtree``
   * - 2
     - Move meta data files to ``_esp_build/``
     - ``shutil.copy``
   * - 3
     - Move ``src/`` content to ``_esp_build/src/espresso``
     - ``shutil.copytree``
   * - 4
     - Move ``contrib/`` content to ``_esp_build/src/espresso/`` + ``_esp_build/src/espresso/__init__.py`` + ``_esp_build/src/espresso/list_problems.py``
     - ``shutil.copytree``, a series of file opening and string manipulation
   * - 5
     - Write dynamic version and extra versioningit configs into ``_esp_build/pyproject.toml``
     - ``versioningit``
   * - 6
     - Install package from ``_esp_build/``
     - ``pip install _esp_build``


Appendix II: validation steps
-----------------------------

To test whether your new contribution aligns with the Espresso standard, run 
the following in your terminal:

.. code-block:: console

   $ python espresso_machine/build_package/validate.py -c <contrib-name>

You can run the validation script before (``--pre`` flag on) and/or after (``--post`` 
flag on) you install your development version of Espresso. A better workflow is to run 
both:

.. code-block:: console

   $ python espresso_machine/build_package/validate.py --pre -c <contrib-name>
   $ python espresso_machine/build_package/build.py
   $ python espresso_machine/build_package/validate.py --post -c <contrib-name>


Or the following for a complete check on all examples (including yours), both before
and after Espresso installed:

.. code-block:: console

   $ python espresso_machine/build_package/build.py


Anyway, run the following for a detailed usage of this script:

.. code-block:: console

   $ python espresso_machine/build_package/validate.py --help


The following table describes what happens when we validate a certain version
of Espresso:

.. list-table:: How an Espresso contribution is validated
   :widths: 10 45 45
   :header-rows: 1

   * - Step
     - What's done
     - How it's done
   * - 1
     - Check the contribution folder name matches the main Python file name (``contrib/<contrib_name>/<contrib_name>.py``)
     - ``assert f"{contrib_name}.py" in file_names``
   * - 2
     - Check ``README.md``, ``LICENCE`` and ``__init__.py`` exist
     - ``assert required_file in file_names``
   * - 3
     - Check the class name is listed in ``__all__`` in file ``__init__.py``
     - ``assert contrib_name_class in parent_module.__all__``
   * - 4
     - Check the contribution provides access to the required metadata
     - Pull out the ``metadata`` field of the contribution class and check those attributes are of correct types
   * - 5
     - Check required methods / properties are implemented and a complete workflow can run for each example number
     - Run from ``example_number=1`` up until an exception is raised or reached 100. For each example, try to get ``model_size``, ``data_size``, ``good_model`` (flat array like, length = ``model_size``), ``starting_model`` (flat array like, length = ``model_size``), ``data`` (flat array like, length = ``data_size``); Run ``forward(model)`` (output to be flat array like, length = ``data_size``). Where "flat array like" is checked via ``np.ndim(obj) == 1``
   * - 6
     - Check optional methods / properties, if implemented, have the correct type signatures
     - For each example, check that the outputs of ``forward(model, with_jacobian=True)``, ``jacobian(model)`` (if implemented) have flat array like synthetics and 2D array like jacobian; Check ``description`` (if exists) is string; Check ``covariance_matrix`` and ``inverse_covariance_matrix`` are in shape ``(data_size, data_size)`` and one is the inverse of the other (if implemented); Check ``plot_model`` and ``plot_data`` (if implemented) return an instance of ``matplotlib.figure.Figure``; Check ``misfit``, ``log_likelihood`` and ``log_prior`` (if implemented) return float
   * - 7
     - Check ``LICENCE`` file is not empty
     - ``assert os.stat("LICENCE").st_size != 0``
